<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"shader.js.html":{"id":"shader.js.html","title":"Source: shader.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: shader.js var fish = fish || {}; fish.shader = (() =&gt; { const defaultVertexShader = ` attribute vec4 position; attribute vec4 textureCoord; uniform vec4 invCanvas; uniform vec2 invTextureSize; varying highp vec2 vTextureCoord; void main() { gl_Position = position * (invCanvas * vec4(2, 2, 1.0, 1.0)) - vec4(1.0, 1.0, 0, 0); vTextureCoord = textureCoord.xy * invTextureSize; }`; const defaultFragmentShader = ` uniform sampler2D sampler; varying highp vec2 vTextureCoord; void main() { gl_FragColor = texture2D(sampler, vTextureCoord); }`; let defaultShader = null; let shader = {}; /** * Loads a shader from text source. * @param gl is the opengl context. * @param type is the type of shader to load. * @param source is the text source code. * @return the created shader or null if it screwed up. */ shader.loadShader = (gl, type, source) =&gt; { const shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.error( 'Could not compiler shader: ' + gl.getShaderInfoLog(shader) ); return null; } return shader; }; /** * Creates a shader out of the source of a vertex and fragment shader. * @param gl is the opengl context. * @param fragmentSrc is the source of the fragment shader which when null * uses a default one. * @param vertexSrc is the source of the vertex shader which when null * uses a default one. * @return the new shader program or null if it failed. */ shader.createShaderProgram = (gl, vertexSrc=null, fragmentSrc=null) =&gt; { const vertex = shader.loadShader( gl, gl.VERTEX_SHADER, vertexSrc ? vertexSrc : defaultVertexShader ); const fragment = shader.loadShader( gl, gl.FRAGMENT_SHADER, fragmentSrc ? fragmentSrc : defaultFragmentShader ); const program = gl.createProgram(); gl.attachShader(program, vertex); gl.attachShader(program, fragment); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { console.error( 'Could not init shader program: ' + gl.getProgramInfoLog(program) ); return null; } const width = gl.drawingBufferWidth; const height = gl.drawingBufferHeight; gl.useProgram(program); const invCanvas = gl.getUniformLocation(program, 'invCanvas'); gl.uniform4f(invCanvas, 1 / width, 1 / height, 1, 1); return { program: program, position: gl.getAttribLocation(program, 'position'), textureCoord: gl.getAttribLocation(program, 'textureCoord'), invTextureSize: gl.getUniformLocation(program, 'invTextureSize'), invCanvas: invCanvas, sampler: gl.getUniformLocation(program, 'sampler') }; }; /** * Binds the default shader for some nice default rendering. * @param gl is the opengl context. */ shader.bindDefaultShader = (gl) =&gt; { if (defaultShader == null) { defaultShader = shader.createShaderProgram(gl); } gl.useProgram(defaultShader.program); return defaultShader; }; return shader; })(); × Search results Close "},"fish.js.html":{"id":"fish.js.html","title":"Source: fish.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: fish.js /** @namespace */ var fish = fish || {}; /** * Init callback which creates the game's starting screen. * @callback fish~init * @param {fish.screen.Context} ctx is the game context with all the subsystems * and stuff. * @return {fish.screen.Screen} the screen created. */ /** * @typedef {Object} fish.start~Args * @param {Object} usr copied to game context usr object. * @param {Object} gfx graphics * @param {Object} snd sound * @param {Object} in input * @param {Object} str store */ /** * Real function that starts the application running. Just takes all of the * subsystems like graphics and audio rather than building them, so that you * can create different ones to your heart's content. * @param rate is the number of logic frames per second to aim for. If you * give a number less than 1 you are asking for variable frame * rate. * @param graphics is the graphics system. * @param audio is the audio system. * @param input is the input system. * @param store is the asset store system. * @param {fish~init} init is the initialisation function that generates the * starting screen. */ fish.start = async function (rate, graphics, audio, input, store, init) { const FRAME_LENGTH = 1 / rate; let ctx = { gfx: graphics, snd: audio, in: input, str: store }; let screen = await init(ctx); if (screen == null) { console.err(\"No Starting Screen. Game Cannot Start.\"); return; } let screens = [screen]; screen.refresh(); const updateScreens = () =&gt; { const response = screens[screens.length - 1].update(FRAME_LENGTH); if (response) { if (response.pop) screens.pop(); if (response.screen) screens.push(response.screen); screens[screens.length - 1].refresh(response.message); } }; setInterval(() =&gt; { if (screens.length &gt; 0) { // TODO: calculate the passage of time better and desync rendering // with updating. ctx.snd.update(); ctx.in.update(); updateScreens(); ctx.gfx.clear(0, 0, 0, 1); for (screen of screens) { screen.render(); } } }, FRAME_LENGTH); }; /** * Starts the thing's main loop ticking along by passing to it the rendering * canvas, and the starting screen. * @param rate is the number of logic frames per second to aim for. If * you give a number less than 1 you are asking for * variable frame rate. * @param gl is a html canvas. * @param audio is the audio context. * @param assetsPrefix is the prefix under which assets are found by the assets * store. * @param {fish~init} init is a function to generate the starting screen. */ fish.normalStart = async function (rate, gl, audio, assetsPrefix, init) { let graphics = new fish.graphics.SpriteRenderer(gl); let fishAudio = new fish.audio.BasicAudio(audio); await fish.start( rate, graphics, fishAudio, new fish.input.BasicInput(), new fish.Store(graphics, fishAudio, assetsPrefix), init ); }; × Search results Close "},"audio.js.html":{"id":"audio.js.html","title":"Source: audio.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: audio.js var fish = fish || {}; /** * This file provides audio playing and loading functionality and a basic sound * player class. This player only supports playing audio files that are fully * loaded into memory, there is no audio streaming because it would lag and * suck. * If you need more flexible audio playing then feel free to create your own * class that does what you need. * @namespace */ fish.audio = {}; /** * Nice little sample object that stores it's name so we can use that for * stuff. You probably don't want to create one of these directly unless you * are creating your own audio system. * @constructor * @param name is the name / url of the samepl. * @param buffer is the actual audio data. */ fish.audio.Sample = function (name, buffer) { this.name = name; this.buffer = buffer; }; /** * Audio player which can play samples, which is the minimum required by the * engine. * @interface fish.audio.SamplePlayer */ /** * Plays a sample. * @method fish.audio.SamplePlayer#playSample * @param {fish.audio.Sample} sample the sample to play. * @param {number} priority determines if this sample can override others if * there are limited resources. */ /** * A basic audio handler that has a music channel, a looping background sound * channel, and a couple of channels for playing sound effects. * @implements fish.audio.SamplePlayer * @constructor * @param {AudioContext} context is the audio context. * @param {number} players is the number of samples that can play at once. */ fish.audio.BasicAudio = function (context, players=3) { let songPlayer = context.createBufferSource(); let noisePlayer = context.createBufferSource(); songPlayer.connect(context.destination); noisePlayer.connect(context.destination); let playingSong = ''; let playingNoise = ''; let soundPlayers = []; let frame = 0; /** * Little thing that holds an audio buffer source and keeps track of what * it is being used for. * @private * @constructor */ let SamplePlayer = function () { let source = context.createBufferSource(); source.connect(context.destination); let playing = false; let start = 0; let sample = null; let priority = 0; /** * Tells you if this sample player is currently playing. * @return true if it is playing. */ this.isPlaying = () =&gt; { return playing; }; /** * Tells you the tick that the current sample started on. * @return the tick as a number. */ this.getStart = () =&gt; { return start; }; /** * Tells you the priority of the currently playing sample on this * thing. Keep in mind if it's not actually playing it's really not * that high priority. * @return the priority of the last played sample. */ this.getPriority = () =&gt; { return priority; }; /** * Play a given sample. * @param sample is the sample to play. * @param priority is the priority to say this had. */ this.play = (sample, priority) =&gt; { playing = true; start = frame; sample = sample; priority = priority; source.buffer = sample.buffer; source.start(0); source.onended = () =&gt; {playing = false;}; }; /** * Tells you if a given sample is the same as the one this one is * playing. * @param sample is the sample to check. * @return true if they are the same and this sample player is still * playing. */ this.same = other =&gt; { return playing &amp;&amp; sample &amp;&amp; sample.name == other.name; }; /** * Tells you if this sample player is less important than another * hypothetical sample player playing with the given properties. * @param otherPriority is the priority of the other sample player. * @param otherStart is the start of the other sample player. * @return true if this one is less important. */ this.lesser = (otherPriority, otherStart) =&gt; { return !playing || priority &lt; otherPriority || (priority == otherPriority &amp;&amp; start &lt; otherStart); }; }; for (let i = 0; i &lt; players; i++) soundPlayers.push(new SamplePlayer()); /** * Updates the audio player. Needs to be done once per frame. */ this.update = () =&gt; { frame++; }; /** * @inheritDoc */ this.playSample = (sample, priority=0) =&gt; { let chosen = -1; let chosenPriority = -99999; let chosenStart = 0; for (let i = 0; i &lt; soundPlayers.length; i++) { if (soundPlayers[i].same(sample) &amp;&amp; soundPlayers[i].getStart() == frame) { return; } if (soundPlayers[i].lesser(chosenPriority, chosenStart)) { chosen = i; chosenPriority = soundPlayers[i].getPriority(); chosenStart = soundPlayers[i].getStart(); } } if (chosen &gt;= 0) { soundPlayers[chosen].play(sample, priority); } }; /** * Play the given song and if it is already playing then do nothing. * @param {fish.audio.Sample} sample is the audio to play. */ this.playSong = sample =&gt; { if (playingSong == sample.name) { return; } playingSong = sample.name; songPlayer.buffer = sample.buffer; songPlayer.start(0); }; /** * Load a song from the store and then play it right away. * @param {fish.Store} store is the store to load from. * @param {string} name is the key to the song as you would normally * use to load it from the store. */ this.loadSong = async function (store, name) { let sample = await store.getSample(name); if (sample) this.playSong(sample); }; /** * Play the given noise and if it is already playing then do nothing. * @param {fish.audio.Sample} sample is the audio to play. */ this.playNoise = sample =&gt; { if (playingNoise == sample.name) { return; } playingNoise = sample.name; noisePlayer.buffer = sample.buffer; noisePlayer.start(0); }; /** * Load a noise from the store and then play it right away. * @param {fish.Store} store is the store to load from. * @param {string} name is the key to the noise as you would normally * use to load it from the store. */ this.loadNoise = async function (store, name) { let sample = await store.getSample(name); if (sample) this.playSong(sample); }; /** * Loads a piece of audio into memory from soem url. * @param {strimg} url is the joint to load from. * @return {Promise&lt;fish.audio.Sample&gt;} the sound I guess assuming it * didn't fuck up. */ this.loadSample = async function (url) { let request = new XMLHttpRequest(); request.open('GET', url, true); request.responseType = 'arraybuffer'; return new Promise((resolve, reject) =&gt; { request.onload = () =&gt; { context.decodeAudioData( request.response, buffer =&gt; { resolve(new fish.audio.Sample(url, buffer)); }, () =&gt; { reject(`Couldn't load sample ${url}`); } ); }; request.send(); }); }; }; × Search results Close "},"graphics.js.html":{"id":"graphics.js.html","title":"Source: graphics.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: graphics.js var fish = fish || {}; /** * This file provides functionality for doing graphics stuff. A lot of it is * made publically accessible so that if you don't like the SpriteRenderer * class for rendering, you can create your own class and use as much existing * functionality as possible to save you some time and potentially make * different rendering classes as interoperable as practical. * So, unless you want to make your own rendering class, probably the only * thing you are going to use from this file is SpriteRenderer. * @namespace */ fish.graphics = {}; /** * Your graphics subsystem of choice can implement it's own font class which * can basically do whatever it needs to, but there are some things the engine * requires so that it can fit text. * @interface fish.graphics.Font */ /** * @method fish.graphics.Font#getHorizontalPadding * @return {number} the number of pixels to put between characters * horizontally. */ /** * @method fish.graphics.Font#getVerticalPadding * @return {number} the number of pixels to put between lines of text. */ /** * @method fish.graphics.Font#getWidth * @param {number} c is the character code to get the width of. * @return {number} the width of the given character in pixels. */ /** * @method fish.graphics.Font#getLineHeight * @return {number} the height of lines drawn with this font. */ /** * Creates a texture object out of a gl texture. You probably don't want to * instantiate one of these directly unless you are creating your own graphics * system. * @constructor * @param {number} glTexture is the open gl reference to the texture. * @param {number} width is the width of the texture. * @param {number} height is the height of the texture. */ fish.graphics.Texture = function (glTexture, width, height) { /** * Gives you the opengl texture. * @return {number} the opengl reference to the texture. */ this.getGlTexture = () =&gt; { return glTexture; }; /** * Gives you the width of the texture. * @return {number} the width. */ this.getWidth = () =&gt; { return width; }; /** * Gives you the height of the texture. * @return {number} the height. */ this.getHeight = () =&gt; { return height; }; }; /** * Stores sprites. You probably don't want to instantiate one of these directly * unless you are creating your own graphics system. * @constructor */ fish.graphics.Atlas = function () { let sprites = {}; /** * Adds a sprite into the atlas. * @param {string} name is the name of the atlas. * @param {fish.util.Rect} sprite is the sprite to add. */ this.add = (name, sprite) =&gt; { sprites[name] = sprite; }; /** * Gets a sprite out of the atlas. * @param {string} name is the name of the sprite to get. * @return {fish.util.Rect} the sprite found or an empty one if it lacks it. */ this.get = name =&gt; { if (name in sprites) return sprites[name]; console.error(`unknown sprite name ${name}`); return new fish.util.Rect(0, 0, 0, 0); }; /** * Gets a 9-patch out of the atlas and makes it for you. If you pass the * border argument then it is used to create the patch, but if you leave it * as 0 then it tries to use the name to discern the border size of the * patch by looking for a number at the end of the name. If neither of * those things are present then an error will be thrown. * @param {string} name name of the sprite the patch is made of. * @param {number} [border=0] the width of the borders of the patch. * @return {fish.graphics.Patch} the created patch. */ this.getPatch = (name, border=0) =&gt; { let sprite = this.get(name); if (border &lt;= 0) { let match = name.match(/\\d+/); if (!match) { throw new Error( 'fish.graphics.Atlas.getPatch requires a border number ' + 'or a sprite with a name that ends with a number' ); } border = parseInt(match[0]); } return new fish.graphics.Patch(sprite, border); }; /** * Tells you the number of sprites. * @return {number} the number of sprites. */ this.n = () =&gt; { return Object.keys(sprites).length; }; /** * The atlas foreach callback structure which gets called on each sprite in * the atlas. * @callback fish.graphics.Atlas~callback * @param {string} name is the name of the sprite. * @param {fish.util.Rect} sprite is the sprite. */ /** * Iterates over all sprites in the atlas. * @param {fish.graphics.Atlas~callback} callback is a callback to run for each one. */ this.forEach = callback =&gt; { for (let sprite in sprites) callback(sprite, sprites[sprite]); }; }; /** * Represents a colour with parts from 0 to 1. * @constructor * @param {number} r is the red part. * @param {number} g is the green part. * @param {number} b is the blue part. * @param {number} a is the transparancy part. */ fish.graphics.Colour = function (r=1, g=1, b=1, a=1) { /** * Red component of the colour from 0 to 1. * @member {number} */ this.r = r; /** * Green component of the colour from 0 to 1. * @member {number} */ this.g = g; /** * Blue component of the colour from 0 to 1. * @member {number} */ this.b = b; /** * The transparancy part of the colour from 0 to 1. * @member {number} */ this.a = a; }; /** * Font that is drawn using an 16x16 grid of characters all having the same * dimensions. * @implements fish.graphics.Font */ fish.graphics.BitmapFont = class { /** * Creates it and adds the sprite to it yeah. * @param {fish.util.Rect} sprite is the sprite from which we get the * characters. */ constructor(sprite) { /** * The font's actual sprite. * @member * @type {fish.util.Rect} * @readonly */ this.sprite = sprite; } /** @inheritDoc */ getHorizontalPadding() { return 0; } /** @inheritDoc */ getVerticalPadding() { return 0; } /** @inheritDoc */ getWidth(c) { return this.sprite.w / 16; } /** @inheritDoc */ getLineHeight() { return this.sprite.h / 16; } }; /** * Asynchronously loads a texture out of a url. This function requires you to * pass a gl context so you probably want to use the version built into the * renderer unless you are making your own graphics system. * @async * @param {string} url is the url to load the texture from. * @return {Promise&lt;fish.graphics.Texture&gt;} the loaded texture. */ fish.graphics.loadTexture = async function (gl, url) { return await new Promise((resolve, reject) =&gt; { const image = new Image(); image.onload = () =&gt; { const texture = gl.createTexture(); gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image ); gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE ); gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE ); gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST ); gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST ); resolve(new fish.graphics.Texture( texture, image.width, image.height )); }; image.onerror = () =&gt; { reject(`failed loading image ${url}`); }; image.src = url; }); }; /** * Loads in the data part of a texture atlas. * @async * @param {string} url is the url to load it from. * @return {Promise&lt;fish.graphics.Atlas&gt;} the created atlas. */ fish.graphics.loadAtlas = async function (url) { let text = await fish.util.loadText(url); if (text == null) return null; let data = JSON.parse(text); let atlas = new fish.graphics.Atlas(); for (let frame in data) { let rect = data[frame]; atlas.add( frame, new fish.util.Rect(rect.x, rect.y, rect.width, rect.height) ); } return atlas; }; /** * 9 patch implementation that uses a sprite rectangle for each part of the * patch. This is just the object that holds the data for the 9 patch. */ fish.graphics.Patch = class { /** * Creates it by giving a sprite and a border around the outside which * becomes the non middle parts. * @param {fish.util.Rect} rect is the overall sprite to make the patch * from. * @param {number} bord is the number of pixels from the outer edge to the * interior. */ constructor(rect, bord) { let hMid = rect.w - bord * 2; let vMid = rect.h - bord * 2; if (hMid &lt; 1 || vMid &lt; 1) { throw `${bord} is too wide a border for ${rect.w},${rect.h}`; } /** * Border width of the patch. * @readonly * @member {number} */ this.BORDER = bord; /** * Top left part of the patch. * @readonly * @member {fish.util.Rect} */ this.TL = new fish.util.Rect(rect.x, rect.y, bord, bord); /** * Top part of the patch. * @readonly * @member {fish.util.Rect} */ this.T = new fish.util.Rect(rect.x + bord, rect.y, hMid, bord); /** * Top right part of the patch. * @readonly * @member {fish.util.Rect} */ this.TR = new fish.util.Rect(rect.x + bord + hMid, rect.y, bord, bord); /** * mid left part of the patch. * @readonly * @member {fish.util.Rect} */ this.ML = new fish.util.Rect(rect.x, rect.y + bord, bord, vMid); /** * middle part of the patch. * @readonly * @member {fish.util.Rect} */ this.M = new fish.util.Rect(rect.x + bord, rect.y + bord, hMid, vMid); /** * mid right part of the patch. * @readonly * @member {fish.util.Rect} */ this.MR = new fish.util.Rect( rect.x + bord + hMid, rect.y + bord, bord, vMid ); /** * bottom left part of the patch. * @readonly * @member {fish.util.Rect} */ this.BL = new fish.util.Rect(rect.x, rect.y + bord + vMid, bord, bord); /** * bottom part of the patch. * @readonly * @member {fish.util.Rect} */ this.B = new fish.util.Rect( rect.x + bord, rect.y + bord + vMid, hMid, bord ); /** * bottom right part of the patch. * @readonly * @member {fish.util.Rect} */ this.BR = new fish.util.Rect( rect.x + bord + hMid, rect.y + bord + vMid, bord, bord ); } }; /** * Core functionality required by the engine for the graphics subsystem to * have. * @interface fish.graphics.BaseRenderer */ /** * Fill the screen with a colour. * @method fish.graphics.BaseRenderer#clear * @param {number} r the red component from 0 to 1. * @param {number} g the green component from 0 to 1. * @param {number} b the blue component from 0 to 1. * @param {number} a the transparent component from 0 to 1. */ /** * Base rendering interface required by the engine internally for gui stuff. * Must be implemented by something in order to use the gui but does not need * to be implemented by the graphics subsystem itself. * @interface */ fish.graphics.PatchRenderer = class { /** * Renders a 9 patch to the given spot. * @param {fish.graphics.Patch} patch is the 9patch to draw. * @param {fish.util.Rect} dst is the place on the screen to draw it. */ renderPatch(patch, dst) { throw new Error( 'fish.graphics.PatchRenderer.renderPatch must be implemented' ); } /** * Renders a piece of text onto the screen using a font. * @param {fish.graphics.Font} font is the font to use to draw the text. * @param {string} text is the text to draw. All it's newlines and stuff * are taken as written. * @param {fish.util.Vector} dst is the top left corner of where the text * will appear on the screen. */ renderText(font, text, dst) { throw new Error( 'fish.graphics.PatchRenderer.renderText must be implemented' ); } }; /** * The default graphics handler which uses a sprite batch to draw nice * pictures. * @implements fish.graphics.BaseRenderer * @constructor * @param gl is the opengl context. */ fish.graphics.SpriteRenderer = function (gl) { let usefulRect = new fish.util.Rect(); let usedTextures = []; gl.disable(gl.DEPTH_TEST); gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA); this.width = gl.drawingBufferWidth; this.height = gl.drawingBufferHeight; console.log(this.width, this.height); /** * A thing that batches draw calls. * @constructor * @implements {fish.graphics.PatchRenderer} * @param {fish.graphics.Texture} texture is the texture all the draws must * be from. * @param {number} max the max things to draw. */ this.Batch = function (texture, max) { let items = new Float32Array(max * 12); let textureItems = new Float32Array(max * 12); let n = 0; let rendered = false; const buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, items, gl.DYNAMIC_DRAW); const textureBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer); gl.bufferData(gl.ARRAY_BUFFER, textureItems, gl.DYNAMIC_DRAW); /** * Adds the given sprite onto the given spot. * @param {fish.util.Rect} src is the sprite to draw. * @param {number} l the distance from left of screen to draw. * @param {number} b the distance from bottom of screen to draw. * @param {number} r the distance from right of screen to stop draw. * @param {number} t the distance from top of screen to stop draw. */ this.addComp = (src, l, b, r, t) =&gt; { if (n &gt;= max) return; const offset = n * 12; items[offset] = l; items[offset + 1] = b; items[offset + 2] = r; items[offset + 3] = b; items[offset + 4] = l; items[offset + 5] = t; items[offset + 6] = r; items[offset + 7] = b; items[offset + 8] = r; items[offset + 9] = t; items[offset + 10] = l; items[offset + 11] = t; textureItems[offset] = src.x; textureItems[offset + 1] = src.t; textureItems[offset + 2] = src.r; textureItems[offset + 3] = src.t; textureItems[offset + 4] = src.x; textureItems[offset + 5] = src.y; textureItems[offset + 6] = src.r; textureItems[offset + 7] = src.t; textureItems[offset + 8] = src.r; textureItems[offset + 9] = src.y; textureItems[offset + 10] = src.x; textureItems[offset + 11] = src.y; n++; }; /** * Adds a sprite to the list of those to draw. I guess rotating would * be good but I would have to do it in software and I dunno what the * performance would be like. * @param {fish.util.Rect} src is the src rectangle from the texture. * @param {fish.util.Rect|fish.util.Vector} dst is where to draw it on * the screen. If it's a vector then that is the centre. * @param {number} scale is used to scale the sprite if you used * a vector. If you used a rect it does nothing. */ this.add = (src, dst, scale=1) =&gt; { let l, r, t, b; if (dst instanceof fish.util.Rect) { l = dst.x; r = dst.r; b = dst.y; t = dst.t; } else if (dst instanceof fish.util.Vector) { let halfScale = scale * 0.5; l = dst.x - src.w * halfScale; r = dst.x + src.w * halfScale; b = dst.y + src.h * halfScale; t = dst.y - src.h * halfScale; } else { throw new TypeError( 'SpriteRenderer.Batch.add requres a Vector or a Rect' ); } this.addComp(src, l, t, r, b); }; /** * Draws a 9 patch at the given place. If you give an area that is too * small it will look munted beware. * @param patch is the 9patch to draw. * @param dst is the place to draw it. */ this.addPatch = (patch, dst) =&gt; { this.addComp( patch.BL, dst.x, dst.y, dst.x + patch.BORDER, dst.y + patch.BORDER ); this.addComp( patch.B, dst.x + patch.BORDER, dst.y, dst.r - patch.BORDER, dst.y + patch.BORDER ); this.addComp( patch.BR, dst.r - patch.BORDER, dst.y, dst.r, dst.y + patch.BORDER ); this.addComp( patch.ML, dst.x, dst.y + patch.BORDER, dst.x + patch.BORDER, dst.t - patch.BORDER ); this.addComp( patch.M, dst.x + patch.BORDER, dst.y + patch.BORDER, dst.r - patch.BORDER, dst.t - patch.BORDER ); this.addComp( patch.MR, dst.r - patch.BORDER, dst.y + patch.BORDER, dst.r, dst.t - patch.BORDER ); this.addComp( patch.TL, dst.x, dst.t - patch.BORDER, dst.x + patch.BORDER, dst.t ); this.addComp( patch.T, dst.x + patch.BORDER, dst.t - patch.BORDER, dst.r - patch.BORDER, dst.t ); this.addComp( patch.TR, dst.r - patch.BORDER, dst.t - patch.BORDER, dst.r, dst.t ); }; /** * Draws text using a bitmap font. * @param {fish.graphics.BitmapFont} font the font that has the text * graphics and drawing info. * @param {string} text what to write including all newlines and stuff. * @param {fish.util.Vector} dst is where on the screen to write the * text. Successive lines will decrease in y position. */ this.addText = (font, text, dst) =&gt; { let width = font.getWidth('n'); let height = font.getLineHeight(); let xOffset = 0; let yOffset = 0; fish.util.aRect.size.set(width, height); for (let i = 0; i &lt; text.length; i++) { let c = text.charCodeAt(i); if (c == 10) { yOffset += height + font.getVerticalPadding(); xOffset = 0; } else { fish.util.aRect.pos.set( font.sprite.x + Math.floor(c % 16) * width, font.sprite.y + Math.floor(c / 16) * height ); this.addComp( fish.util.aRect, dst.x + xOffset, dst.y - yOffset - height, dst.x + xOffset + width, dst.y - yOffset ); xOffset += width + font.getHorizontalPadding(); } } }; /** @inheritDoc */ this.renderPatch = (patch, dst) =&gt; { this.addPatch(patch, dst); }; /** @inheritDoc */ this.renderText = (font, text, dst) =&gt; { this.addText(font, text, dst); }; /** * Blanks the contents of the batch to go again. */ this.clear = () =&gt; { rendered = false; n = 0; }; /** * Renders what the batch currently has to the screen. */ this.render = () =&gt; { if (rendered) { console.error('repeat batch rendering without clear'); return; } rendered = true; let shader = fish.shader.bindDefaultShader(gl); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferSubData(gl.ARRAY_BUFFER, 0, items); gl.vertexAttribPointer(shader.position, 2, gl.FLOAT, false, 0, 0); gl.enableVertexAttribArray(shader.position); gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer); gl.bufferSubData(gl.ARRAY_BUFFER, 0, textureItems); gl.vertexAttribPointer( shader.textureCoord, 2, gl.FLOAT, false, 0, 0 ); gl.enableVertexAttribArray(shader.textureCoord); // TODO: decide active texture better. gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture.getGlTexture()); gl.uniform1i(shader.sampler, 0); gl.uniform2f( shader.invTextureSize, 1 / texture.getWidth(), 1 / texture.getHeight() ); gl.drawArrays(gl.TRIANGLES, 0, n * 6); }; }; /** * Loads a texture using this graphics thing's gl context. * @param {string} url is the url of the texture to load. * @return {Promise&lt;fish.graphics.Texture&gt;} the texture if it worked. */ this.loadTexture = async function (url) { return await fish.graphics.loadTexture(gl, url); }; /** * @inheritDoc */ this.clear = (r=1, g=1, b=1, a=1) =&gt; { gl.clearColor(r, g, b, a); gl.clear(gl.COLOR_BUFFER_BIT); }; /** * Clears the screen with a colour object. * @param {fish.graphics.Colour} colour is the colour to clear with. */ this.clearColour = colour =&gt; { this.clear(colour.r, colour.g, colour.b, colour.a); }; }; /** * @constant * @type fish.graphics.Colour */ fish.graphics.BLACK = new fish.graphics.Colour(0, 0, 0, 1); /** * @constant * @type fish.graphics.Colour */ fish.graphics.WHITE = new fish.graphics.Colour(1, 1, 1, 1); /** * @constant * @type fish.graphics.Colour */ fish.graphics.RED = new fish.graphics.Colour(1, 0, 0, 1); /** * @constant * @type fish.graphics.Colour */ fish.graphics.GREEN = new fish.graphics.Colour(0, 1, 0, 1); /** * @constant * @type fish.graphics.Colour */ fish.graphics.BLUE = new fish.graphics.Colour(0, 0, 1, 1); × Search results Close "},"gui.js.html":{"id":"gui.js.html","title":"Source: gui.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: gui.js var fish = fish || {}; /** * This file provides a kinda basic gui system for the user to interact with. * It only uses button input by default but it should be able to do menu type * stuff as well as game dialogue and basic hud if need be etc. * In the future I might add mouse support to the default input system in which * case I will also make the gui be able to use mouse at least if you want it * to. * @namespace */ fish.gui = {}; /** * Stores all the style information used to draw gui elements in one place. * It's just an object so that if I add more style stuff later it won't break * your code and you won't be using the new gui things that use the new stuff * anyway. * @interface fish.gui.Style */ /** * The font for writing text in the gui. * @member fish.gui.Style#font * @type fish.util.Rect */ /** * The patch to draw panels with. * @member fish.gui.Style#panel * @type fish.graphics.Patch */ /** * The patch to draw buttons with. * @member fish.gui.Style#button * @type fish.graphics.Patch */ /** * The patch to draw depressed buttons with. * @member fish.gui.Style#buttonDown * @type fish.graphics.Patch */ /** * The patch to draw over stuff that is selected. * @member fish.gui.Style#select * @type fish.graphics.Patch */ /** * Base gui knob class. Yeah I call it knob instead of element or something * because element is long as hell and gay. */ fish.gui.Knob = class { /** * @param {fish.gui.Style} style is used to style it. */ constructor(style) { this.fitted = false; this.bounds = null; this.style = style; } /** * Tells you if this type of gui knob is selectable. If not then you cannot * interact with it. * @return {boolean} true iff you can interact. */ selectable() { return false; } /** * Fits the gui knob to the given area. Probably needs to be extended to be * useful a lot of the time. * @param {fish.util.Rect} bounds is the area to fit the element into. * @param {boolean} greedy whether to fill all available space even if not * needed. This is what is wanted generally if user code calls fit, * and sometimes it's needed for inner gui bits, but you obviously * can't use it for every situation. Also, keep in mind it's more * like a guideline than a rule, some things really can't be * greedy, and some have no choice but to be greedy. */ fit(bounds, greedy=true) { this.bounds = bounds; this.fitted = true; } /** * Updates the knob so that it can react to user input and potentially * return some stuff. Should recurse for nested elements. * @param {fish.input.UiInput} input is used to check if keys are pressed * or whatever. * @param {fish.audio.SamplePlayer} audio is used to play sound effects * like buttons clicking and shit. * @return {?Object} whatever you want to return, this is handled by user * code. If you return from a nested gui element the outer ones * should just return it recursively. If you return null that is * considered to mean nothing happened. */ update(input, audio) { return null; } /** * Renders the gui element using the given patch renderer. * @abstract * @param {fish.graphics.PatchRenderer} patchRenderer does the rendering. * @param {boolean} selected is whether the knob is currently selected. */ render(patchRenderer, selected) { throw new Error('fish.gui.knob.render must be implemented'); } }; /** * Holds basic code for knobs that contain a bunch of other knobs so you don't * have to write a million variations of the same basic functionality. */ fish.gui.ContainerKnob = class extends fish.gui.Knob { /** * @param {fish.gui.Style} styles the container. * @param {Array.&lt;fish.gui.Knob&gt;} children is a list of children to add * stright away. */ constructor(style, children) { super(style); this.hasSelectable = false; this.selection = 0; this.children = []; for (let child of children) this.addChild(child); } /** @inheritDoc */ selectable() { return this.hasSelectable; } /** * Increases or decreases the currently selected child. * @param {number} direction is whether to go forward (&gt; 0) or back (&lt; 0). * If you pass 0 nothing will happen. */ incrementSelection(direction) { if (direction == 0 || !this.hasSelectable) return; let change = Math.sign(direction); for (let i = 0; i &lt; this.children.length &amp;&amp; change != 0; i++) { this.selection += change; if (this.selection &lt; 0) this.selection = this.children.length - 1; if (this.selection &gt;= this.children.length) this.selection = 0; if (this.children[this.selection].selectable()) change = 0; } } /** * Adds a child to the container. * @param {fish.gui.Knob} child is the thing to add. */ addChild(child) { this.children.push(child); if (child.selectable() &amp;&amp; !this.hasSelectable) { this.hasSelectable = true; this.selection = this.children.length - 1; } } }; /** * Creates a panel that can stack contents vertically or horizontally in a nice * box. * @implements fish.gui.Knob */ fish.gui.PanelKnob = class extends fish.gui.ContainerKnob { /** * @param {fish.gui.Style} style used to style it. * @param {boolean} [cancellable=false] is if pressing UI_BUTTON.CANCEL * will cause the panel to return null on the next update. * @param {Array.&lt;fish.gui.Knob&gt;} [children=[]] is a list of knobs to add as * children to this panel. */ constructor(style, cancellable=false, children=[]) { super(style, children); this.cancellable = cancellable; } /** @inheritDoc */ fit(bounds, greedy=true) { let interior = bounds.copy(); interior.shrink(this.style.panel.BORDER); for (let i in this.children) { this.children[i].fit( interior.copy(), i == this.children.length - 1 &amp;&amp; greedy ); interior.size.y -= this.children[i].bounds.h; } if (greedy) { super.fit(bounds); } else { super.fit(new fish.util.Rect( bounds.x, bounds.y + interior.h, bounds.w, bounds.h - interior.h )); } } /** @inheritDoc */ update(input, audio) { if (this.cancellable &amp;&amp; input.uiDown(fish.input.UI_BUTTON.CANCEL)) { return null; } if (this.children.length == 0) return null; if (input.uiJustDown(fish.input.UI_BUTTON.UP)) { this.incrementSelection(-1); } else if (input.uiJustDown(fish.input.UI_BUTTON.DOWN)) { this.incrementSelection(1); } return this.children[this.selection].update(input, audio); } /** @inheritDoc */ render(patchRenderer, selected) { patchRenderer.renderPatch(this.style.panel, this.bounds); for (let i in this.children) { this.children[i].render( patchRenderer, selected &amp;&amp; i == this.selection ); } } }; /** * Knob that just holds some text and does nothing. * @implements fish.gui.Knob */ fish.gui.TextKnob = class extends fish.gui.Knob { /** * @param {fish.gui.Style} style the style used by the knob. * @param {string} text the unwrapped text in which only multiple newlines * are counted as newlines. */ constructor(style, text) { super(style); this.text = text; this.fittedText = ''; this.origin = new fish.util.Vector(); } /** @inheritDoc */ fit(bounds, greedy=true) { this.origin.x = bounds.x + 1; this.origin.y = bounds.t - 1; this.fittedText = fish.util.fitText( this.text, this.style.font, bounds.w - 2 ); let height = fish.util.textHeight(this.fittedText, this.style.font) + 2; bounds.pos.y += bounds.size.y - height; bounds.size.y = height; super.fit(bounds); } /** @inheritDoc */ render(patchRenderer, selected) { patchRenderer.renderText( this.style.font, this.fittedText, this.origin ); } }; /** * A button that you can have a nice click of. * @implements fish.gui.Knob */ fish.gui.ButtonKnob = class extends fish.gui.Knob { /** * @param {fish.gui.Style} style is the style to draw it with. * @param {string|fish.gui.Knob} child is the child to put inside the * button. If you passed text it is assumed you want it to be made * into a text knob. * @param {?mixed} result is the thing to return from update if the button * is pressed. Be warned, though, if this is a function it will be * executed and then it's return value will be returned instead. */ constructor(style, child, result=null) { super(style); this.down = false; this.result = result; if (typeof child == 'string') { this.child = new fish.gui.TextKnob(style, child); } else { this.child = child; } } /** @inheritDoc */ selectable() { return true; } /** @inheritDoc */ fit(bounds, greedy=true) { let interior = bounds.copy(); interior.shrink(this.style.button.BORDER); this.child.fit(interior); if (!greedy) { bounds.size.y = this.child.bounds.size.y + this.style.button.BORDER * 2; bounds.pos.y = this.child.bounds.pos.y - this.style.button.BORDER; } super.fit(bounds); } /** @inheritDoc */ update(input, audio) { if (input.uiDown(fish.input.UI_BUTTON.ACCEPT) &amp;&amp; !this.down) { audio.playSample(this.style.click); this.down = true; if (typeof this.result == 'function') { return this.result(); } return this.result; } return null; } /** @inheritDoc */ render(patchRenderer, selected) { patchRenderer.renderPatch( selected ? this.style.buttonSelected : this.style.button, this.bounds ); this.child.render(patchRenderer, selected); } }; /** * Displays a picture nestled within the gui system. */ fish.gui.PicKnob = class extends fish.gui.Knob { /** * @param {fish.gui.Style} style the style. * @param {mixed} sprite the pic to draw. * @param {number} [scale=1] is the scale to draw it at. If the knob ends * up being fitted greedily this will be ignored. * @param {boolean} [stretch=false] is whether the image should eschew it's * aspect ratio to fill all the space it is given. */ constructor(style, sprite, scale=1, stretch=false) { super(style); this.sprite = sprite; this.scale = scale; this.stretch = stretch; } }; /** * Like a panel but it stores it's contents in equally sized areas separated * by vertical lines. */ fish.gui.HBoxKnob = class extends fish.gui.ContainerKnob { /** * @param {fish.gui.Style} style decides how stuff is displayed. * @param {Array.&lt;fish.gui.Knob&gt;} [children=[]] is a list of children to * add to the hbox right away. */ constructor(style, children=[]) { super(style, children); } /** @inheritDoc */ fit(bounds, greedy=true) { let interior = bounds.copy(); let maxHeight = 0; interior.size.x /= this.children.length; for (let child of this.children) { child.fit(interior.copy(), greedy); interior.pos.x += interior.size.x; maxHeight = Math.max(maxHeight, child.bounds.size.y); } if (!greedy) bounds.size.y = maxHeight; super.fit(bounds, greedy); } /** @inheritDoc */ update(input, audio) { if (this.children.length == 0) return null; if (input.uiJustDown(fish.input.UI_BUTTON.LEFT)) { this.incrementSelection(-1); } else if (input.uiJustDown(fish.input.UI_BUTTON.RIGHT)) { this.incrementSelection(1); } return this.children[this.selection].update(input, audio); } /** @inheritDoc */ render(patchRenderer, selected) { for (let i in this.children) { this.children[i].render( patchRenderer, selected &amp;&amp; i == this.selection ); } } }; × Search results Close "},"input.js.html":{"id":"input.js.html","title":"Source: input.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: input.js var fish = fish || {}; /** * Contains the base input handler and a couple of button constants that are * required to be handled by the gui system. If you create your input handler * you just need to make sure you implement uiDown and uiJustDown so that it * will work with the gui system. * @namespace */ fish.input = {}; /** * UI buttons that all input handling subsystems have to handle (but they can * be mapped into your control scheme however you want). * @readonly * @enum {string} */ fish.input.UI_BUTTON = { /** move up in menus etc */ UP: 'UP', /** move down in menus etc */ DOWN: 'DOWN', /** move left in menus etc */ LEFT: 'LEFT', /** move right in menus etc */ RIGHT: 'RIGHT', /** accept dialogs and things */ ACCEPT: 'ACCEPT', /** go back and cancel things etc */ CANCEL: 'CANCEL' }; /** * Basic ui operations required by the engine for an input system. * @interface */ fish.input.UiInput = class { /** * Tells you if the given ui button is currently down. * @param {fish.input.UI_BUTTON} button is the button to check on. * @return {boolean} true iff it is down. */ uiDown(button) { throw new Error('fish.input.UiInput.uiDown must be implemented'); } /** * Tells you if the given ui button just went down. * @param {fish.input.UI_BUTTON} button is the button to check on. * @return {boolean} true iff it is down. */ uiJustDown(button) { throw new Error('fish.input.UiInput.uiJustDown must be implemented'); } }; /** * An input handler system that unifies all input from gamepads / keyboard * into one abstract input which is supposed to work like a gamepad basically. * It only works with 1 player games for that reason. * @constructor * @implements {fish.input.UiInput} * @param {Object.&lt;string, string&gt;} [keymap={}] a mapping from html key names * to button on the virtual controller. * @param {number} [threshold=0.9] the threshold beyond which a gamepad axis is * considered pressed. */ fish.input.BasicInput = function (keymap={}, threshole=0.9) { /** * The buttons that this imaginary controller provides. * @readonly * @enum {string} */ this.BUTTON = { /** Left axis on controller pointed up. */ UP: 'UP', /** Left axis on controller pointed down. */ DOWN: 'DOWN', /** Left axis on controller pointed left. */ LEFT: 'LEFT', /** Left axis on controller pointed right. */ RIGHT: 'RIGHT', /** X button like on xbox controller. */ X: 'X', /** Y button like on xbox controller. */ Y: 'Y', /** A button like on xbox controller. */ A: 'A', /** B button like on xbox controller. */ B: 'B', /** left trigger button. */ L: 'L', /** right trigger button. */ R: 'R', /** left menu button. */ SELECT: 'SELECT', /** right menu button thing. Generally the pause button. */ START: 'START' }; if (!keymap.UP) keymap.UP = 'ArrowUp'; if (!keymap.DOWN) keymap.DOWN = 'ArrowDown'; if (!keymap.LEFT) keymap.LEFT = 'ArrowLeft'; if (!keymap.RIGHT) keymap.RIGHT = 'ArrowRight'; if (!keymap.A) keymap.A = 'Shift'; if (!keymap.B) keymap.B = 'z'; if (!keymap.X) keymap.X = 'a'; if (!keymap.Y) keymap.Y = 'x'; if (!keymap.L) keymap.L = 'd'; if (!keymap.R) keymap.R = 'c'; if (!keymap.SELECT) keymap.SELECT = 'Escape'; if (!keymap.START) keymap.START = 'Enter'; let frame = 0; let keys = {}; let buttonStates = {}; for (let button in this.BUTTON) { buttonStates[button] = 0; } document.addEventListener('keydown', (e) =&gt; {keys[e.key] = true;}); document.addEventListener('keyup', (e) =&gt; {keys[e.key] = false;}); /** * Tells you if the given button is pressed whether it is a number or * a button object thing. * @param {string|number} button is either a number or a button object thingo. * @return {boolean} true iff it is pressed. */ let pressed = button =&gt; { if (typeof(button) == 'object') { return button.pressed; } return button == 1.0; }; /** * Sets a button to the correct value based on whether it is pressed or not * rn. * @param {string} button is the button to update. * @param {boolean} value is whether or not it is pressed right now. * @param {boolean} include is whether to keep the value that is already * there. */ let updateButton = (button, value, include=false) =&gt; { if (include) value = value || buttonStates[button] &gt; 0; if (!value) buttonStates[button] = 0; else if (buttonStates[button] == 0) buttonStates[button] = frame; }; /** * Converts a ui button to an actual button on this controller thing. * @param {string} uiCode is the code to convert. * @return {string} the corresponding actual button. */ let uiToButton = uiCode =&gt; { switch (uiCode) { case fish.input.UI_BUTTON.UP: return this.BUTTON.UP; case fish.input.UI_BUTTON.DOWN: return this.BUTTON.DOWN; case fish.input.UI_BUTTON.LEFT: return this.BUTTON.LEFT; case fish.input.UI_BUTTON.RIGHT: return this.BUTTON.RIGHT; case fish.input.UI_BUTTON.ACCEPT: return this.BUTTON.A; case fish.input.UI_BUTTON.CANCEL: return this.BUTTON.B; } throw uiCode; }; /** * Just iterates the frame number. */ this.update = () =&gt; { frame++; let gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []); for (let button in this.BUTTON) { updateButton(button, keys[keymap[button]]); } for (let pad of gamepads) { updateButton(this.BUTTON.A, pressed(pad.buttons[0]), true); updateButton(this.BUTTON.B, pressed(pad.buttons[1]), true); updateButton(this.BUTTON.X, pressed(pad.buttons[2]), true); updateButton(this.BUTTON.Y, pressed(pad.buttons[3]), true); updateButton(this.BUTTON.L, pressed(pad.buttons[4]), true); updateButton(this.BUTTON.R, pressed(pad.buttons[5]), true); updateButton(this.BUTTON.SELECT, pressed(pad.buttons[8]), true); updateButton(this.BUTTON.START, pressed(pad.buttons[9]), true); updateButton( this.BUTTON.UP, pressed(pad.buttons[12]) || pad.axes[1] &lt; -threshold, true ); updateButton( this.BUTTON.DOWN, pressed(pad.buttons[13]) || pad.axes[1] &gt; threshold, true ); updateButton( this.BUTTON.LEFT, pressed(pad.buttons[14]) || pad.axes[0] &lt; -threshold, true ); updateButton( this.BUTTON.RIGHT, pressed(pad.buttons[15]) || pad.axes[0] &gt; threshold, true ); } }; /** * Tells you if the given input is pressed. * @param {string} code represents the iinput button thing. * @return {boolean} true if it is pressed. */ this.down = code =&gt; { if (!(code in buttonStates)) throw code; return buttonStates[code] &gt; 0; }; /** * Tells you if the given input was pressed this frame I think. * @param {string} code is the code to represent or whatever. * @return {boolean} true if it was pressed this frame. */ this.justDown = code =&gt; { if (!(code in buttonStates)) throw code; return buttonStates[code] == frame; }; /** @inheritDoc */ this.uiDown = uiCode =&gt; { return this.down(uiToButton(uiCode)); }; /** @inheritDoc */ this.uiJustDown = uiCode =&gt; { return this.justDown(uiToButton(uiCode)); }; }; × Search results Close "},"screen.js.html":{"id":"screen.js.html","title":"Source: screen.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: screen.js var fish = fish || {}; /** * Contains the screen class and the context class which holds the subsystem * for screens. * @namespace */ fish.screen = {}; /** * Stores all the game's subsystems. Now, you will notice that these are all * interface types that the engine provides. You will control what the * implementing type is and for god's sake don't try to do any static type * crazy bullshit with this. Just accept that the actual implementing types of * these are the ones you asked for in your game. * These interfaces are just the basic amount of functionality that the engine * requires from each subsystem. * @typedef {Object} fish.screen~Context * @param {fish.graphics.BaseRenderer} gfx the graphics subsystem. * @param {fish.audio.SamplePlayer} snd the audio subsystem. * @param {fish.input.UiInput} in the input subsystem. * @param {fish.store.Store} str the asset store. * @param {Object} usr basically a namespace where you can store your own junk * without fear of future versions of the engine overwriting it. */ /** * Represents a transition between screens on the screen stack. */ fish.screen.Transition = class { /** * There are three different configurations that this constructor allows. * When pop is true the current screen is removed, when screen is not null * then that screen is placed on the stack. Thus, you can push a screen on * this screen, replace this screen with another, or you can just pop this * screen. If you set pop to false and screen to null then nothing will * happen. * @param {boolean} pop whether to pop the returning screen from the screen * stack. * @param {?fish.screen.Screen} screen is a screen to add to the screen * stack if given. * @param {?Object} message a message that will be given to whatever screen * is going to next have reveal called on it. */ constructor(pop, screen=null, message=null) { this.pop = pop; this.screen = screen; this.message = message; } }; /** * Basic screen class which does nothing and should be extended. */ fish.screen.Screen = class { /** * Creates the screen and gives it the context object that contains all the * subsystems and stuff. * @param {fish.screen~Context} ctx is stored by the base screen class so you * always have access to it. */ constructor(ctx) { this.ctx = ctx; } /** * Called by the engine whenever the screen gets onto the top of the screen * stack. * @param {?Object} message something sent from the screen that allowed * this screen to be revealed. Could be a return value from a screen * this one pushed on top of itself or whatever you want. */ refresh(message) { // by default does nothing. } /** * Updates the screen. * @param {number} delta is the amount of time passage to update for in * seconds. * @return {?fish.screen.Transition} the update thing that tells the engine * what to do next with regards to the screen stack. If null is * returned then nothing is done. */ update(delta) { // by default does nothing. return null; } /** * Renders the screen. * @param {boolean} front is whether this screen is the top one being * rendered. */ render(front) { // does nothing by default. } }; × Search results Close "},"Store.js.html":{"id":"Store.js.html","title":"Source: Store.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: Store.js var fish = fish || {}; /** * Class that stores assets. * @constructor * @param graphics is the graphics system which loads textures. * @param audio is the audio system which loads samples. * @param {string} prefix is a prefix appended to urls. */ fish.Store = function (graphics, audio, prefix) { let assets = {}; let loaders = { texture: graphics.loadTexture, atlas: fish.graphics.loadAtlas, sample: audio.loadSample }; /** * Gets a thing of arbitrary type from the asset store, or creates and adds * it if it cannot be found. * @param {string} name is the name of the thing to find. * @param {string} type is the type of the thing to find. * @return the thing if it is found or null. */ let get = async function (name, type) { if (!(name in assets)) { if (type in loaders) { let item = await loaders[type](prefix + name); assets[name] = item; } else { console.error(`${type} is a not a valid asset type`); assets[name] = null; } } return assets[name]; }; /** * Gets a texture. * @async * @param {string} name is the name of the texture to get. * @return {fish.graphics.Texture} the texture it got. */ this.getTexture = async function (name) { return await get(name, 'texture'); }; /** * Gets a texture atlas thingy. * @async * @param {string} name is the name of the atlas to get. * @return {fish.graphics.Atlas} the thingy. */ this.getAtlas = async function (name) { return await get(name, 'atlas'); }; /** * Loads a sound sample. * @async * @param {string} name is the name of the sample to g4et. * @return {fish.audio.Sample} the sample or null if it screwed up. */ this.getSample = async function (name) { return await get(name, 'sample'); }; }; × Search results Close "},"util.js.html":{"id":"util.js.html","title":"Source: util.js","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Source: util.js var fish = fish || {}; /** * Provides some basic utility stuff. Maths classes and whatever the hell ya * know. * @namespace */ fish.util = {}; /** * Represents a two dimensional point / direction via cartesian coordinates. * You will notice there is no functional style stuff and that is because it * requires instantiating objects and in the kinds of contexts where a vector * class is most used, that is not really acceptable so yeah. * @constructor * @param {number} [x=0] is the horizontal part. * @param {number} [y=0] is the vector part. */ fish.util.Vector = function (x=0, y=0) { this.x = x; this.y = y; /** * Sets both parts of the vector to new values. * @param {number} [x=0] is the new x part. * @param {number} [y=0] is the new y part. */ this.set = (x=0, y=0) =&gt; { this.x = x; this.y = y; }; /** * Adds another vector onto this one component wise. * @param {fish.util.Vector} other is the other vector. * @param {number} [mag=1] is the amount to multiply the other one by * first. I know it's not really that relevant to adding but it is * the main use case so I might as well make it efficient and easy. */ this.add = (other, mag=1) =&gt; { this.x += other.x * mag; this.y += other.y * mag; }; /** * Wraps this vector in a rectangle that starts at (0, 0) then goes to * bounds. * @param {fish.util.Vector} bounds is a vector representing the far * corner. */ this.wrap = (bounds) =&gt; { this.x = (this.x &lt; 0) ? (bounds.x - Math.abs(this.x % bounds.x)) : (this.x % bounds.x); this.y = (this.y &lt; 0) ? (bounds.y - Math.abs(this.y % bounds.y)) : (this.y % bounds.y); }; }; /** * Represents an axis aligned rectangle and it should be immutable I think. * wait no. But I should make it immutable maybe. */ fish.util.Rect = class { /** * Creates the rectangle. * @param {number} [x=0] is the horizontal position of the rectangle. * @param {number} [y=0] is the vertical position of the rectangle. * @param {number} [w=0] is the width of the rectangle. * @param {number} [h=0] is the height of the rectangle. */ constructor(x=0, y=0, w=0, h=0) { this.pos = new fish.util.Vector(x, y); this.size = new fish.util.Vector(w, h); } copy() { return new fish.util.Rect(this.x, this.y, this.w, this.h); } /** * Shrinks the rectangle by a certain amount from each of it's former * border lines. * @param {number} amount the amount to shrink it from each side. */ shrink(amount) { this.pos.x += amount; this.pos.y += amount; this.size.x -= amount * 2; this.size.y -= amount * 2; } /** * Gets the horizontal position of the rectangle. * @return {number} x */ get x() { return this.pos.x; } /** * Gets the vertical position of the rectangle. * @return {number} y */ get y() { return this.pos.y; } /** * Gets the width of the rectangle. * @return {number} w */ get w() { return this.size.x; } /** * Gets the height of the rectangle. * @return {number} h */ get h() { return this.size.y; } /** * Gets the position of the right hand side of the rectangle. Or left * depending on how you look at it. Essentially it's x + w. * @return {number} x + w */ get r() { return this.pos.x + this.size.x; } /** * Gets the position of the top of the rectangle. Or bottom depending on * how you are thinking about it. Point is it's y + h. * @return {number} y + h */ get t() { return this.pos.y + this.size.y; } }; /** * Asynchronously loads a text file in. * @param {string} url is the url to load the file from. * @return {Promise&lt;string&gt;} that resolves to the loaded file content. */ fish.util.loadText = async function (url) { return await new Promise((resolve, reject) =&gt; { let xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (this.readyState == 4) { if (this.status == 200) resolve(this.responseText); else reject( `couldn't get file '${url}', response code ${this.status}` ); } }; xhr.open('GET', url, true); xhr.send(); }); }; /** * Takes a piece of text and fits it so that when drawn with a given font it * will fit into a given width space. It ignores single newlines, and turns two * or more newlines in a row into a single newline. * @param {string} text the text to fit. * @param {fish.graphics.Font} font the font to give size to the text. * @param {number} width the width to fit the text into. */ fish.util.fitText = (text, font, width) =&gt; { console.log(width); let fitted = ''; let lines = text.split(/\\n\\n+/); for (let line of lines) { let offset = 0; let tokens = line.split(/\\s/); for (let token of tokens) { if (token.length == 0) continue; let size = (token.length - 1) * font.getHorizontalPadding(); for (let i = 0; i &lt; token.length; i++) { size += font.getWidth(token.charAt(i)); } if (offset + size &gt; width) { fitted += `\\n${token}`; offset = size; } else { fitted += token; offset += size; } offset += font.getWidth(' '); fitted += ' '; } fitted += '\\n'; } return fitted; }; /** * Takes a fitted piece of text and tells you how high it is gonna be in the * given font. * @param {string} text is text where every newline is taken seriously. * @param {fish.graphics.Font} font is the font used to measure it. * @return {number} the number of pixels high it will be. */ fish.util.textHeight = (text, font) =&gt; { let lines = text.split(/\\n(?=\\S+)/).length; return lines * font.getLineHeight() + (lines - 1) * font.getVerticalPadding(); }; /** * This is a rect that you can use for stuff when you don't want to instantiate * one. Just know that in between uses it's value could be arbitrary. */ fish.util.aRect = new fish.util.Rect(); × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Classes Classes BasicAudio Sample Atlas BitmapFont Colour Patch SpriteRenderer Batch Texture ButtonKnob ContainerKnob HBoxKnob Knob PanelKnob PicKnob TextKnob BasicInput Screen Transition Store Rect Vector Namespaces fish audio graphics gui input screen util × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespaces Classes BasicAudio Sample Atlas BitmapFont Colour Patch SpriteRenderer Batch Texture ButtonKnob ContainerKnob HBoxKnob Knob PanelKnob PicKnob TextKnob BasicInput Screen Transition Store Rect Vector Namespaces fish audio graphics gui input screen util × Search results Close "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Interfaces Classes BasicAudio Sample Atlas BitmapFont Colour Patch SpriteRenderer Batch Texture ButtonKnob ContainerKnob HBoxKnob Knob PanelKnob PicKnob TextKnob BasicInput Screen Transition Store Rect Vector Namespaces fish audio graphics gui input screen util × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput fish-tank 1.0.0 This is the fish-tank official mascot and he is named Vabongaringo. He is 600 years old and has committed multiple war crimes for which he was never caught. Every browser based game library sucks real bad real good UNTIL NOW... Wahooo, we now have fish-tank; a browser based game library that takes loose inspiration from lua love since it's real nice but not browser based obviously. We have: Not much state. Nice interfaces for default subsystems you can rewrite any subsystem you want as long as you implement a small interface. cool looking gui system. batched sprite rendering on gpu with great performance. The Subsystems The core functionality of the engine is in it's subsystems. ctx.gfx: the renderer fish.graphics.SpriteRenderer by default ctx.in: the input handler fish.input.BasicInput by default ctx.snd: the sound player fish.audio.BasicAudio by default ctx.str: the asset store fish.store.Store by default Each of these has an intentionally quite specific but easy to use and nice interface which is real nice 99% of the time since the interfaces on these subsystems is basically the usable system that I end up building on top of other game engine's systems when their built in interface to these features is painful. For example, the renderer uses gpu accelerated sprite batching which provides a really good tradeoff between speed and clean code and programmer ease. The input system maps all connected gamepads and the keyboard to a single imaginary game controller which you can then poll the buttons of in your game code. Right now the systems are pretty minimal, I might also add some more features to them. Below is a section on adding new subsystems but there is no point forcing people to create new subsystems just because I was too lazy to add a few basic features, you know. If you wish they had a feature you could email me or make a github ticket or whatever and I will discuss whether it should be added to the built in subsystems or made into a custom subsystem. Pull Requests would be appreciated but it's probably better if you talk to me first because I'm not gonna merge things I don't want simply out of politeness. Now, as I said, these easy to use systems are real nice 99% of the time, but sometimes you need a different way of doing things, which these rather imposing interfaces can only support to a point. This brings us to the next section. Implementing your own versions of the subsystems 99% of the functionality of the subsystem is only used in your actual game code and so the engine doesn't care about it, there are just a couple of small interfaces you will need to implement so that your new subsystem can interact with the other ones. For graphics, there is the fish.graphics.BaseRenderer interface and the fish.graphics.PatchRenderer interface, I know it seems weird that there are two but you might not actually use the same object to perform both of those tasks and you don't have to. The base renderer interface is the for basic stuff like filling the screen with colour, and the patch renderer is for rendering styled rectangles and text. There is also the fish.graphics.Font interface which your renderer's font implementation that it uses to draw text must implement. This is just for getting the size of pieces of text and stuff like that, other than that your font and text rendering system can be whatever you want. For audio, there is the fish.audio.SamplePlayer interface that requires your audio implementation to be able to play samples on command. For input, there is the fish.input.UiInput interface which requires the input subsystem to be able to provide information about the user interacting with the ui. It is currently only based on button presses but you can map these to whatever buttons or inputs you want to in your implementation. The asset store has no interface because it is only used in user code, but you can replace it if you want to. I don't really know of a good reason to bother though tbh. Starting the Game fish.start takes a fairly complicated set of arguments. × Search results Close "},"fish.html":{"id":"fish.html","title":"Namespace: fish","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespace: fish fish Source: fish.js, line 2 Classes Store Namespaces audio graphics gui input screen util Methods &lt;static&gt; normalStart(rate, gl, audio, assetsPrefix, init) Starts the thing's main loop ticking along by passing to it the rendering canvas, and the starting screen. Parameters: Name Type Description rate is the number of logic frames per second to aim for. If you give a number less than 1 you are asking for variable frame rate. gl is a html canvas. audio is the audio context. assetsPrefix is the prefix under which assets are found by the assets store. init fish~init is a function to generate the starting screen. Source: fish.js, line 86 &lt;static&gt; start(rate, graphics, audio, input, store, init) Real function that starts the application running. Just takes all of the subsystems like graphics and audio rather than building them, so that you can create different ones to your heart's content. Parameters: Name Type Description rate is the number of logic frames per second to aim for. If you give a number less than 1 you are asking for variable frame rate. graphics is the graphics system. audio is the audio system. input is the input system. store is the asset store system. init fish~init is the initialisation function that generates the starting screen. Source: fish.js, line 35 Type Definitions init(ctx) Init callback which creates the game's starting screen. Parameters: Name Type Description ctx fish.screen.Context is the game context with all the subsystems and stuff. Source: fish.js, line 4 Returns: the screen created. Type fish.screen.Screen × Search results Close "},"fish.audio.html":{"id":"fish.audio.html","title":"Namespace: audio","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespace: audio fish. audio This file provides audio playing and loading functionality and a basic sound player class. This player only supports playing audio files that are fully loaded into memory, there is no audio streaming because it would lag and suck. If you need more flexible audio playing then feel free to create your own class that does what you need. Source: audio.js, line 12 Classes BasicAudio Sample × Search results Close "},"fish.audio.BasicAudio.html":{"id":"fish.audio.BasicAudio.html","title":"Class: BasicAudio","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: BasicAudio fish.audio. BasicAudio new BasicAudio(context, players) A basic audio handler that has a music channel, a looping background sound channel, and a couple of channels for playing sound effects. Parameters: Name Type Description context AudioContext is the audio context. players number is the number of samples that can play at once. Implements: fish.audio.SamplePlayer Source: audio.js, line 49 Methods loadNoise(store, name) Load a noise from the store and then play it right away. Parameters: Name Type Description store fish.Store is the store to load from. name string is the key to the noise as you would normally use to load it from the store. Source: audio.js, line 213 loadSample(url) Loads a piece of audio into memory from soem url. Parameters: Name Type Description url strimg is the joint to load from. Source: audio.js, line 224 Returns: the sound I guess assuming it didn't fuck up. Type Promise.&lt;fish.audio.Sample&gt; loadSong(store, name) Load a song from the store and then play it right away. Parameters: Name Type Description store fish.Store is the store to load from. name string is the key to the song as you would normally use to load it from the store. Source: audio.js, line 189 playNoise(sample) Play the given noise and if it is already playing then do nothing. Parameters: Name Type Description sample fish.audio.Sample is the audio to play. Source: audio.js, line 198 playSample(sample, priority) Plays a sample. Parameters: Name Type Description sample fish.audio.Sample the sample to play. priority number determines if this sample can override others if there are limited resources. Implements: fish.audio.SamplePlayer#playSample Source: audio.js, line 33 playSong(sample) Play the given song and if it is already playing then do nothing. Parameters: Name Type Description sample fish.audio.Sample is the audio to play. Source: audio.js, line 174 update() Updates the audio player. Needs to be done once per frame. Source: audio.js, line 143 × Search results Close "},"fish.audio.Sample.html":{"id":"fish.audio.Sample.html","title":"Class: Sample","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Sample fish.audio. Sample new Sample(name, buffer) Nice little sample object that stores it's name so we can use that for stuff. You probably don't want to create one of these directly unless you are creating your own audio system. Parameters: Name Type Description name is the name / url of the samepl. buffer is the actual audio data. Source: audio.js, line 22 × Search results Close "},"fish.audio.SamplePlayer.html":{"id":"fish.audio.SamplePlayer.html","title":"Interface: SamplePlayer","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Interface: SamplePlayer fish.audio. SamplePlayer Audio player which can play samples, which is the minimum required by the engine. Source: audio.js, line 27 Methods playSample(sample, priority) Plays a sample. Parameters: Name Type Description sample fish.audio.Sample the sample to play. priority number determines if this sample can override others if there are limited resources. Source: audio.js, line 33 × Search results Close "},"fish.graphics.html":{"id":"fish.graphics.html","title":"Namespace: graphics","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespace: graphics fish. graphics This file provides functionality for doing graphics stuff. A lot of it is made publically accessible so that if you don't like the SpriteRenderer class for rendering, you can create your own class and use as much existing functionality as possible to save you some time and potentially make different rendering classes as interoperable as practical. So, unless you want to make your own rendering class, probably the only thing you are going to use from this file is SpriteRenderer. Source: graphics.js, line 13 Classes Atlas BitmapFont Colour Patch SpriteRenderer Texture Members &lt;static, constant&gt; BLACK :fish.graphics.Colour Type: fish.graphics.Colour Source: graphics.js, line 768 &lt;static, constant&gt; BLUE :fish.graphics.Colour Type: fish.graphics.Colour Source: graphics.js, line 792 &lt;static, constant&gt; GREEN :fish.graphics.Colour Type: fish.graphics.Colour Source: graphics.js, line 786 &lt;static, constant&gt; RED :fish.graphics.Colour Type: fish.graphics.Colour Source: graphics.js, line 780 &lt;static, constant&gt; WHITE :fish.graphics.Colour Type: fish.graphics.Colour Source: graphics.js, line 774 Methods &lt;async, static&gt; loadAtlas(url) Loads in the data part of a texture atlas. Parameters: Name Type Description url string is the url to load it from. Source: graphics.js, line 297 Returns: the created atlas. Type Promise.&lt;fish.graphics.Atlas&gt; &lt;async, static&gt; loadTexture(url) Asynchronously loads a texture out of a url. This function requires you to pass a gl context so you probably want to use the version built into the renderer unless you are making your own graphics system. Parameters: Name Type Description url string is the url to load the texture from. Source: graphics.js, line 241 Returns: the loaded texture. Type Promise.&lt;fish.graphics.Texture&gt; × Search results Close "},"fish.graphics.Atlas.html":{"id":"fish.graphics.Atlas.html","title":"Class: Atlas","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Atlas fish.graphics. Atlas new Atlas() Stores sprites. You probably don't want to instantiate one of these directly unless you are creating your own graphics system. Source: graphics.js, line 84 Methods add(name, sprite) Adds a sprite into the atlas. Parameters: Name Type Description name string is the name of the atlas. sprite fish.util.Rect is the sprite to add. Source: graphics.js, line 92 forEach(callback) Iterates over all sprites in the atlas. Parameters: Name Type Description callback fish.graphics.Atlas~callback is a callback to run for each one. Source: graphics.js, line 152 get(name) Gets a sprite out of the atlas. Parameters: Name Type Description name string is the name of the sprite to get. Source: graphics.js, line 101 Returns: the sprite found or an empty one if it lacks it. Type fish.util.Rect getPatch(name [, border]) Gets a 9-patch out of the atlas and makes it for you. If you pass the border argument then it is used to create the patch, but if you leave it as 0 then it tries to use the name to discern the border size of the patch by looking for a number at the end of the name. If neither of those things are present then an error will be thrown. Parameters: Name Type Argument Default Description name string name of the sprite the patch is made of. border number &lt;optional&gt; 0 the width of the borders of the patch. Source: graphics.js, line 117 Returns: the created patch. Type fish.graphics.Patch n() Tells you the number of sprites. Source: graphics.js, line 136 Returns: the number of sprites. Type number Type Definitions callback(name, sprite) The atlas foreach callback structure which gets called on each sprite in the atlas. Parameters: Name Type Description name string is the name of the sprite. sprite fish.util.Rect is the sprite. Source: graphics.js, line 140 × Search results Close "},"fish.graphics.BaseRenderer.html":{"id":"fish.graphics.BaseRenderer.html","title":"Interface: BaseRenderer","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Interface: BaseRenderer fish.graphics. BaseRenderer Core functionality required by the engine for the graphics subsystem to have. Source: graphics.js, line 419 Methods clear(r, g, b, a) Fill the screen with a colour. Parameters: Name Type Description r number the red component from 0 to 1. g number the green component from 0 to 1. b number the blue component from 0 to 1. a number the transparent component from 0 to 1. Source: graphics.js, line 425 × Search results Close "},"fish.graphics.BitmapFont.html":{"id":"fish.graphics.BitmapFont.html","title":"Class: BitmapFont","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: BitmapFont fish.graphics. BitmapFont Font that is drawn using an 16x16 grid of characters all having the same dimensions. new BitmapFont(sprite) Creates it and adds the sprite to it yeah. Parameters: Name Type Description sprite fish.util.Rect is the sprite from which we get the characters. Implements: fish.graphics.Font Source: graphics.js, line 196 Members &lt;readonly&gt; sprite :fish.util.Rect The font's actual sprite. Type: fish.util.Rect Source: graphics.js, line 209 Methods getHorizontalPadding() Implements: fish.graphics.Font#getHorizontalPadding Source: graphics.js, line 22 Returns: the number of pixels to put between characters horizontally. Type number getLineHeight() Implements: fish.graphics.Font#getLineHeight Source: graphics.js, line 39 Returns: the height of lines drawn with this font. Type number getVerticalPadding() Implements: fish.graphics.Font#getVerticalPadding Source: graphics.js, line 28 Returns: the number of pixels to put between lines of text. Type number getWidth(c) Parameters: Name Type Description c number is the character code to get the width of. Implements: fish.graphics.Font#getWidth Source: graphics.js, line 33 Returns: the width of the given character in pixels. Type number × Search results Close "},"fish.graphics.Colour.html":{"id":"fish.graphics.Colour.html","title":"Class: Colour","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Colour fish.graphics. Colour new Colour(r, g, b, a) Represents a colour with parts from 0 to 1. Parameters: Name Type Description r number is the red part. g number is the green part. b number is the blue part. a number is the transparancy part. Source: graphics.js, line 165 Members a :number The transparancy part of the colour from 0 to 1. Type: number Source: graphics.js, line 188 b :number Blue component of the colour from 0 to 1. Type: number Source: graphics.js, line 182 g :number Green component of the colour from 0 to 1. Type: number Source: graphics.js, line 176 r :number Red component of the colour from 0 to 1. Type: number Source: graphics.js, line 170 × Search results Close "},"fish.graphics.Font.html":{"id":"fish.graphics.Font.html","title":"Interface: Font","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Interface: Font fish.graphics. Font Your graphics subsystem of choice can implement it's own font class which can basically do whatever it needs to, but there are some things the engine requires so that it can fit text. Source: graphics.js, line 15 Methods getHorizontalPadding() Source: graphics.js, line 22 Returns: the number of pixels to put between characters horizontally. Type number getLineHeight() Source: graphics.js, line 39 Returns: the height of lines drawn with this font. Type number getVerticalPadding() Source: graphics.js, line 28 Returns: the number of pixels to put between lines of text. Type number getWidth(c) Parameters: Name Type Description c number is the character code to get the width of. Source: graphics.js, line 33 Returns: the width of the given character in pixels. Type number × Search results Close "},"fish.graphics.Patch.html":{"id":"fish.graphics.Patch.html","title":"Class: Patch","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Patch fish.graphics. Patch 9 patch implementation that uses a sprite rectangle for each part of the patch. This is just the object that holds the data for the 9 patch. new Patch(rect, bord) Creates it by giving a sprite and a border around the outside which becomes the non middle parts. Parameters: Name Type Description rect fish.util.Rect is the overall sprite to make the patch from. bord number is the number of pixels from the outer edge to the interior. Source: graphics.js, line 316 Members &lt;readonly&gt; B :fish.util.Rect bottom part of the patch. Type: fish.util.Rect Source: graphics.js, line 398 &lt;readonly&gt; BL :fish.util.Rect bottom left part of the patch. Type: fish.util.Rect Source: graphics.js, line 391 &lt;readonly&gt; BORDER :number Border width of the patch. Type: number Source: graphics.js, line 337 &lt;readonly&gt; BR :fish.util.Rect bottom right part of the patch. Type: fish.util.Rect Source: graphics.js, line 410 &lt;readonly&gt; M :fish.util.Rect middle part of the patch. Type: fish.util.Rect Source: graphics.js, line 372 &lt;readonly&gt; ML :fish.util.Rect mid left part of the patch. Type: fish.util.Rect Source: graphics.js, line 365 &lt;readonly&gt; MR :fish.util.Rect mid right part of the patch. Type: fish.util.Rect Source: graphics.js, line 379 &lt;readonly&gt; T :fish.util.Rect Top part of the patch. Type: fish.util.Rect Source: graphics.js, line 351 &lt;readonly&gt; TL :fish.util.Rect Top left part of the patch. Type: fish.util.Rect Source: graphics.js, line 344 &lt;readonly&gt; TR :fish.util.Rect Top right part of the patch. Type: fish.util.Rect Source: graphics.js, line 358 × Search results Close "},"fish.graphics.PatchRenderer.html":{"id":"fish.graphics.PatchRenderer.html","title":"Interface: PatchRenderer","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Interface: PatchRenderer fish.graphics. PatchRenderer Base rendering interface required by the engine internally for gui stuff. Must be implemented by something in order to use the gui but does not need to be implemented by the graphics subsystem itself. Source: graphics.js, line 440 Methods renderPatch(patch, dst) Renders a 9 patch to the given spot. Parameters: Name Type Description patch fish.graphics.Patch is the 9patch to draw. dst fish.util.Rect is the place on the screen to draw it. Source: graphics.js, line 446 renderText(font, text, dst) Renders a piece of text onto the screen using a font. Parameters: Name Type Description font fish.graphics.Font is the font to use to draw the text. text string is the text to draw. All it's newlines and stuff are taken as written. dst fish.util.Vector is the top left corner of where the text will appear on the screen. Source: graphics.js, line 460 × Search results Close "},"fish.graphics.SpriteRenderer.html":{"id":"fish.graphics.SpriteRenderer.html","title":"Class: SpriteRenderer","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: SpriteRenderer fish.graphics. SpriteRenderer new SpriteRenderer(gl) The default graphics handler which uses a sprite batch to draw nice pictures. Parameters: Name Type Description gl is the opengl context. Implements: fish.graphics.BaseRenderer Source: graphics.js, line 474 Classes Batch Methods clear(r, g, b, a) Fill the screen with a colour. Parameters: Name Type Description r number the red component from 0 to 1. g number the green component from 0 to 1. b number the blue component from 0 to 1. a number the transparent component from 0 to 1. Implements: fish.graphics.BaseRenderer#clear Source: graphics.js, line 425 clearColour(colour) Clears the screen with a colour object. Parameters: Name Type Description colour fish.graphics.Colour is the colour to clear with. Source: graphics.js, line 759 loadTexture(url) Loads a texture using this graphics thing's gl context. Parameters: Name Type Description url string is the url of the texture to load. Source: graphics.js, line 743 Returns: the texture if it worked. Type Promise.&lt;fish.graphics.Texture&gt; × Search results Close "},"fish.graphics.SpriteRenderer_Batch.html":{"id":"fish.graphics.SpriteRenderer_Batch.html","title":"Class: Batch","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Batch fish.graphics.SpriteRenderer# Batch new Batch(texture, max) A thing that batches draw calls. Parameters: Name Type Description texture fish.graphics.Texture is the texture all the draws must be from. max number the max things to draw. Implements: fish.graphics.PatchRenderer Source: graphics.js, line 492 Methods add(src, dst, scale) Adds a sprite to the list of those to draw. I guess rotating would be good but I would have to do it in software and I dunno what the performance would be like. Parameters: Name Type Description src fish.util.Rect is the src rectangle from the texture. dst fish.util.Rect | fish.util.Vector is where to draw it on the screen. If it's a vector then that is the centre. scale number is used to scale the sprite if you used a vector. If you used a rect it does nothing. Source: graphics.js, line 552 addComp(src, l, b, r, t) Adds the given sprite onto the given spot. Parameters: Name Type Description src fish.util.Rect is the sprite to draw. l number the distance from left of screen to draw. b number the distance from bottom of screen to draw. r number the distance from right of screen to stop draw. t number the distance from top of screen to stop draw. Source: graphics.js, line 512 addPatch(patch, dst) Draws a 9 patch at the given place. If you give an area that is too small it will look munted beware. Parameters: Name Type Description patch is the 9patch to draw. dst is the place to draw it. Source: graphics.js, line 580 addText(font, text, dst) Draws text using a bitmap font. Parameters: Name Type Description font fish.graphics.BitmapFont the font that has the text graphics and drawing info. text string what to write including all newlines and stuff. dst fish.util.Vector is where on the screen to write the text. Successive lines will decrease in y position. Source: graphics.js, line 654 clear() Blanks the contents of the batch to go again. Source: graphics.js, line 695 render() Renders what the batch currently has to the screen. Source: graphics.js, line 703 renderPatch(patch, dst) Renders a 9 patch to the given spot. Parameters: Name Type Description patch fish.graphics.Patch is the 9patch to draw. dst fish.util.Rect is the place on the screen to draw it. Implements: fish.graphics.PatchRenderer#renderPatch Source: graphics.js, line 446 renderText(font, text, dst) Renders a piece of text onto the screen using a font. Parameters: Name Type Description font fish.graphics.Font is the font to use to draw the text. text string is the text to draw. All it's newlines and stuff are taken as written. dst fish.util.Vector is the top left corner of where the text will appear on the screen. Implements: fish.graphics.PatchRenderer#renderText Source: graphics.js, line 460 × Search results Close "},"fish.graphics.Texture.html":{"id":"fish.graphics.Texture.html","title":"Class: Texture","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Texture fish.graphics. Texture new Texture(glTexture, width, height) Creates a texture object out of a gl texture. You probably don't want to instantiate one of these directly unless you are creating your own graphics system. Parameters: Name Type Description glTexture number is the open gl reference to the texture. width number is the width of the texture. height number is the height of the texture. Source: graphics.js, line 53 Methods getGlTexture() Gives you the opengl texture. Source: graphics.js, line 58 Returns: the opengl reference to the texture. Type number getHeight() Gives you the height of the texture. Source: graphics.js, line 74 Returns: the height. Type number getWidth() Gives you the width of the texture. Source: graphics.js, line 66 Returns: the width. Type number × Search results Close "},"fish.gui.html":{"id":"fish.gui.html","title":"Namespace: gui","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespace: gui fish. gui This file provides a kinda basic gui system for the user to interact with. It only uses button input by default but it should be able to do menu type stuff as well as game dialogue and basic hud if need be etc. In the future I might add mouse support to the default input system in which case I will also make the gui be able to use mouse at least if you want it to. Source: gui.js, line 12 Classes ButtonKnob ContainerKnob HBoxKnob Knob PanelKnob PicKnob TextKnob × Search results Close "},"fish.gui.ButtonKnob.html":{"id":"fish.gui.ButtonKnob.html","title":"Class: ButtonKnob","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: ButtonKnob fish.gui. ButtonKnob A button that you can have a nice click of. new ButtonKnob(style, child, result) Parameters: Name Type Argument Default Description style fish.gui.Style is the style to draw it with. child string | fish.gui.Knob is the child to put inside the button. If you passed text it is assumed you want it to be made into a text knob. result mixed &lt;nullable&gt; null is the thing to return from update if the button is pressed. Be warned, though, if this is a function it will be executed and then it's return value will be returned instead. Implements: fish.gui.Knob Source: gui.js, line 284 Methods fit(bounds, greedy) Fits the gui knob to the given area. Probably needs to be extended to be useful a lot of the time. Parameters: Name Type Default Description bounds fish.util.Rect is the area to fit the element into. greedy boolean true whether to fill all available space even if not needed. This is what is wanted generally if user code calls fit, and sometimes it's needed for inner gui bits, but you obviously can't use it for every situation. Also, keep in mind it's more like a guideline than a rule, some things really can't be greedy, and some have no choice but to be greedy. Implements: fish.gui.Knob#fit Source: gui.js, line 86 render(patchRenderer, selected) Renders the gui element using the given patch renderer. Parameters: Name Type Description patchRenderer fish.graphics.PatchRenderer does the rendering. selected boolean is whether the knob is currently selected. Implements: fish.gui.Knob#render Source: gui.js, line 113 selectable() Tells you if this type of gui knob is selectable. If not then you cannot interact with it. Implements: fish.gui.Knob#selectable Source: gui.js, line 71 Returns: true iff you can interact. Type boolean update(input, audio) Updates the knob so that it can react to user input and potentially return some stuff. Should recurse for nested elements. Parameters: Name Type Description input fish.input.UiInput is used to check if keys are pressed or whatever. audio fish.audio.SamplePlayer is used to play sound effects like buttons clicking and shit. Implements: fish.gui.Knob#update Source: gui.js, line 103 Returns: whatever you want to return, this is handled by user code. If you return from a nested gui element the outer ones should just return it recursively. If you return null that is considered to mean nothing happened. Type Object × Search results Close "},"fish.gui.ContainerKnob.html":{"id":"fish.gui.ContainerKnob.html","title":"Class: ContainerKnob","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: ContainerKnob fish.gui. ContainerKnob Holds basic code for knobs that contain a bunch of other knobs so you don't have to write a million variations of the same basic functionality. new ContainerKnob(styles, children) Parameters: Name Type Description styles fish.gui.Style the container. children Array.&lt;fish.gui.Knob&gt; is a list of children to add stright away. Source: gui.js, line 122 Methods addChild(child) Adds a child to the container. Parameters: Name Type Description child fish.gui.Knob is the thing to add. Source: gui.js, line 161 incrementSelection(direction) Increases or decreases the currently selected child. Parameters: Name Type Description direction number is whether to go forward (&gt; 0) or back (&lt; 0). If you pass 0 nothing will happen. Source: gui.js, line 146 selectable() Source: gui.js, line 137 × Search results Close "},"fish.gui.HBoxKnob.html":{"id":"fish.gui.HBoxKnob.html","title":"Class: HBoxKnob","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: HBoxKnob fish.gui. HBoxKnob Like a panel but it stores it's contents in equally sized areas separated by vertical lines. new HBoxKnob(style [, children]) Parameters: Name Type Argument Default Description style fish.gui.Style decides how stuff is displayed. children Array.&lt;fish.gui.Knob&gt; &lt;optional&gt; [] is a list of children to add to the hbox right away. Source: gui.js, line 370 Methods fit() Source: gui.js, line 381 render() Source: gui.js, line 406 update() Source: gui.js, line 395 × Search results Close "},"fish.gui.Knob.html":{"id":"fish.gui.Knob.html","title":"Class: Knob","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Knob fish.gui. Knob Base gui knob class. Yeah I call it knob instead of element or something because element is long as hell and gay. new Knob(style) Parameters: Name Type Description style fish.gui.Style is used to style it. Source: gui.js, line 56 Methods fit(bounds, greedy) Fits the gui knob to the given area. Probably needs to be extended to be useful a lot of the time. Parameters: Name Type Default Description bounds fish.util.Rect is the area to fit the element into. greedy boolean true whether to fill all available space even if not needed. This is what is wanted generally if user code calls fit, and sometimes it's needed for inner gui bits, but you obviously can't use it for every situation. Also, keep in mind it's more like a guideline than a rule, some things really can't be greedy, and some have no choice but to be greedy. Source: gui.js, line 86 &lt;abstract&gt; render(patchRenderer, selected) Renders the gui element using the given patch renderer. Parameters: Name Type Description patchRenderer fish.graphics.PatchRenderer does the rendering. selected boolean is whether the knob is currently selected. Source: gui.js, line 113 selectable() Tells you if this type of gui knob is selectable. If not then you cannot interact with it. Source: gui.js, line 71 Returns: true iff you can interact. Type boolean update(input, audio) Updates the knob so that it can react to user input and potentially return some stuff. Should recurse for nested elements. Parameters: Name Type Description input fish.input.UiInput is used to check if keys are pressed or whatever. audio fish.audio.SamplePlayer is used to play sound effects like buttons clicking and shit. Source: gui.js, line 103 Returns: whatever you want to return, this is handled by user code. If you return from a nested gui element the outer ones should just return it recursively. If you return null that is considered to mean nothing happened. Type Object × Search results Close "},"fish.gui.PanelKnob.html":{"id":"fish.gui.PanelKnob.html","title":"Class: PanelKnob","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: PanelKnob fish.gui. PanelKnob Creates a panel that can stack contents vertically or horizontally in a nice box. new PanelKnob(style [, cancellable] [, children]) Parameters: Name Type Argument Default Description style fish.gui.Style used to style it. cancellable boolean &lt;optional&gt; false is if pressing UI_BUTTON.CANCEL will cause the panel to return null on the next update. children Array.&lt;fish.gui.Knob&gt; &lt;optional&gt; [] is a list of knobs to add as children to this panel. Implements: fish.gui.Knob Source: gui.js, line 175 Methods fit(bounds, greedy) Fits the gui knob to the given area. Probably needs to be extended to be useful a lot of the time. Parameters: Name Type Default Description bounds fish.util.Rect is the area to fit the element into. greedy boolean true whether to fill all available space even if not needed. This is what is wanted generally if user code calls fit, and sometimes it's needed for inner gui bits, but you obviously can't use it for every situation. Also, keep in mind it's more like a guideline than a rule, some things really can't be greedy, and some have no choice but to be greedy. Implements: fish.gui.Knob#fit Source: gui.js, line 86 render(patchRenderer, selected) Renders the gui element using the given patch renderer. Parameters: Name Type Description patchRenderer fish.graphics.PatchRenderer does the rendering. selected boolean is whether the knob is currently selected. Implements: fish.gui.Knob#render Source: gui.js, line 113 update(input, audio) Updates the knob so that it can react to user input and potentially return some stuff. Should recurse for nested elements. Parameters: Name Type Description input fish.input.UiInput is used to check if keys are pressed or whatever. audio fish.audio.SamplePlayer is used to play sound effects like buttons clicking and shit. Implements: fish.gui.Knob#update Source: gui.js, line 103 Returns: whatever you want to return, this is handled by user code. If you return from a nested gui element the outer ones should just return it recursively. If you return null that is considered to mean nothing happened. Type Object × Search results Close "},"fish.gui.PicKnob.html":{"id":"fish.gui.PicKnob.html","title":"Class: PicKnob","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: PicKnob fish.gui. PicKnob Displays a picture nestled within the gui system. new PicKnob(style, sprite [, scale] [, stretch]) Parameters: Name Type Argument Default Description style fish.gui.Style the style. sprite mixed the pic to draw. scale number &lt;optional&gt; 1 is the scale to draw it at. If the knob ends up being fitted greedily this will be ignored. stretch boolean &lt;optional&gt; false is whether the image should eschew it's aspect ratio to fill all the space it is given. Source: gui.js, line 349 × Search results Close "},"fish.gui.Style.html":{"id":"fish.gui.Style.html","title":"Interface: Style","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Interface: Style fish.gui. Style Stores all the style information used to draw gui elements in one place. It's just an object so that if I add more style stuff later it won't break your code and you won't be using the new gui things that use the new stuff anyway. Source: gui.js, line 14 Members button :fish.graphics.Patch The patch to draw buttons with. Type: fish.graphics.Patch Source: gui.js, line 34 buttonDown :fish.graphics.Patch The patch to draw depressed buttons with. Type: fish.graphics.Patch Source: gui.js, line 40 font :fish.util.Rect The font for writing text in the gui. Type: fish.util.Rect Source: gui.js, line 22 panel :fish.graphics.Patch The patch to draw panels with. Type: fish.graphics.Patch Source: gui.js, line 28 select :fish.graphics.Patch The patch to draw over stuff that is selected. Type: fish.graphics.Patch Source: gui.js, line 46 × Search results Close "},"fish.gui.TextKnob.html":{"id":"fish.gui.TextKnob.html","title":"Class: TextKnob","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: TextKnob fish.gui. TextKnob Knob that just holds some text and does nothing. new TextKnob(style, text) Parameters: Name Type Description style fish.gui.Style the style used by the knob. text string the unwrapped text in which only multiple newlines are counted as newlines. Implements: fish.gui.Knob Source: gui.js, line 242 Methods fit(bounds, greedy) Fits the gui knob to the given area. Probably needs to be extended to be useful a lot of the time. Parameters: Name Type Default Description bounds fish.util.Rect is the area to fit the element into. greedy boolean true whether to fill all available space even if not needed. This is what is wanted generally if user code calls fit, and sometimes it's needed for inner gui bits, but you obviously can't use it for every situation. Also, keep in mind it's more like a guideline than a rule, some things really can't be greedy, and some have no choice but to be greedy. Implements: fish.gui.Knob#fit Source: gui.js, line 86 render(patchRenderer, selected) Renders the gui element using the given patch renderer. Parameters: Name Type Description patchRenderer fish.graphics.PatchRenderer does the rendering. selected boolean is whether the knob is currently selected. Implements: fish.gui.Knob#render Source: gui.js, line 113 × Search results Close "},"fish.input.html":{"id":"fish.input.html","title":"Namespace: input","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespace: input fish. input Contains the base input handler and a couple of button constants that are required to be handled by the gui system. If you create your input handler you just need to make sure you implement uiDown and uiJustDown so that it will work with the gui system. Source: input.js, line 10 Classes BasicInput Members &lt;static, readonly&gt; UI_BUTTON :string UI buttons that all input handling subsystems have to handle (but they can be mapped into your control scheme however you want). Type: string Properties: Name Type Default Description UP string UP move up in menus etc DOWN string DOWN move down in menus etc LEFT string LEFT move left in menus etc RIGHT string RIGHT move right in menus etc ACCEPT string ACCEPT accept dialogs and things CANCEL string CANCEL go back and cancel things etc Source: input.js, line 18 × Search results Close "},"fish.input.BasicInput.html":{"id":"fish.input.BasicInput.html","title":"Class: BasicInput","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: BasicInput fish.input. BasicInput new BasicInput( [keymap] [, threshold]) An input handler system that unifies all input from gamepads / keyboard into one abstract input which is supposed to work like a gamepad basically. It only works with 1 player games for that reason. Parameters: Name Type Argument Default Description keymap Object.&lt;string, string&gt; &lt;optional&gt; {} a mapping from html key names to button on the virtual controller. threshold number &lt;optional&gt; 0.9 the threshold beyond which a gamepad axis is considered pressed. Implements: fish.input.UiInput Source: input.js, line 68 Members &lt;readonly&gt; BUTTON :string The buttons that this imaginary controller provides. Type: string Properties: Name Type Default Description UP string UP Left axis on controller pointed up. DOWN string DOWN Left axis on controller pointed down. LEFT string LEFT Left axis on controller pointed left. RIGHT string RIGHT Left axis on controller pointed right. X string X X button like on xbox controller. Y string Y Y button like on xbox controller. A string A A button like on xbox controller. B string B B button like on xbox controller. L string L left trigger button. R string R right trigger button. SELECT string SELECT left menu button. START string START right menu button thing. Generally the pause button. Source: input.js, line 74 Methods down(code) Tells you if the given input is pressed. Parameters: Name Type Description code string represents the iinput button thing. Source: input.js, line 213 Returns: true if it is pressed. Type boolean justDown(code) Tells you if the given input was pressed this frame I think. Parameters: Name Type Description code string is the code to represent or whatever. Source: input.js, line 223 Returns: true if it was pressed this frame. Type boolean uiDown(button) Tells you if the given ui button is currently down. Parameters: Name Type Description button fish.input.UI_BUTTON is the button to check on. Implements: fish.input.UiInput#uiDown Source: input.js, line 43 Returns: true iff it is down. Type boolean uiJustDown(button) Tells you if the given ui button just went down. Parameters: Name Type Description button fish.input.UI_BUTTON is the button to check on. Implements: fish.input.UiInput#uiJustDown Source: input.js, line 52 Returns: true iff it is down. Type boolean update() Just iterates the frame number. Source: input.js, line 169 &lt;inner&gt; pressed(button) Tells you if the given button is pressed whether it is a number or a button object thing. Parameters: Name Type Description button string | number is either a number or a button object thingo. Source: input.js, line 128 Returns: true iff it is pressed. Type boolean &lt;inner&gt; uiToButton(uiCode) Converts a ui button to an actual button on this controller thing. Parameters: Name Type Description uiCode string is the code to convert. Source: input.js, line 154 Returns: the corresponding actual button. Type string &lt;inner&gt; updateButton(button, value, include) Sets a button to the correct value based on whether it is pressed or not rn. Parameters: Name Type Default Description button string is the button to update. value boolean is whether or not it is pressed right now. include boolean false is whether to keep the value that is already there. Source: input.js, line 143 × Search results Close "},"fish.input.UiInput.html":{"id":"fish.input.UiInput.html","title":"Interface: UiInput","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Interface: UiInput fish.input. UiInput Basic ui operations required by the engine for an input system. Source: input.js, line 37 Methods uiDown(button) Tells you if the given ui button is currently down. Parameters: Name Type Description button fish.input.UI_BUTTON is the button to check on. Source: input.js, line 43 Returns: true iff it is down. Type boolean uiJustDown(button) Tells you if the given ui button just went down. Parameters: Name Type Description button fish.input.UI_BUTTON is the button to check on. Source: input.js, line 52 Returns: true iff it is down. Type boolean × Search results Close "},"fish.screen.html":{"id":"fish.screen.html","title":"Namespace: screen","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespace: screen fish. screen Contains the screen class and the context class which holds the subsystem for screens. Source: screen.js, line 8 Classes Screen Transition Type Definitions Context Stores all the game's subsystems. Now, you will notice that these are all interface types that the engine provides. You will control what the implementing type is and for god's sake don't try to do any static type crazy bullshit with this. Just accept that the actual implementing types of these are the ones you asked for in your game. These interfaces are just the basic amount of functionality that the engine requires from each subsystem. Type: Object Source: screen.js, line 10 × Search results Close "},"fish.screen.Screen.html":{"id":"fish.screen.Screen.html","title":"Class: Screen","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Screen fish.screen. Screen Basic screen class which does nothing and should be extended. new Screen(ctx) Creates the screen and gives it the context object that contains all the subsystems and stuff. Parameters: Name Type Description ctx fish.screen~Context is stored by the base screen class so you always have access to it. Source: screen.js, line 55 Methods refresh(message) Called by the engine whenever the screen gets onto the top of the screen stack. Parameters: Name Type Argument Description message Object &lt;nullable&gt; something sent from the screen that allowed this screen to be revealed. Could be a return value from a screen this one pushed on top of itself or whatever you want. Source: screen.js, line 73 render(front) Renders the screen. Parameters: Name Type Description front boolean is whether this screen is the top one being rendered. Source: screen.js, line 95 update(delta) Updates the screen. Parameters: Name Type Description delta number is the amount of time passage to update for in seconds. Source: screen.js, line 85 Returns: the update thing that tells the engine what to do next with regards to the screen stack. If null is returned then nothing is done. Type fish.screen.Transition × Search results Close "},"fish.screen.Transition.html":{"id":"fish.screen.Transition.html","title":"Class: Transition","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Transition fish.screen. Transition Represents a transition between screens on the screen stack. new Transition(pop, screen, message) There are three different configurations that this constructor allows. When pop is true the current screen is removed, when screen is not null then that screen is placed on the stack. Thus, you can push a screen on this screen, replace this screen with another, or you can just pop this screen. If you set pop to false and screen to null then nothing will happen. Parameters: Name Type Argument Default Description pop boolean whether to pop the returning screen from the screen stack. screen fish.screen.Screen &lt;nullable&gt; null is a screen to add to the screen stack if given. message Object &lt;nullable&gt; null a message that will be given to whatever screen is going to next have reveal called on it. Source: screen.js, line 30 × Search results Close "},"fish.Store.html":{"id":"fish.Store.html","title":"Class: Store","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Store fish. Store new Store(graphics, audio, prefix) Class that stores assets. Parameters: Name Type Description graphics is the graphics system which loads textures. audio is the audio system which loads samples. prefix string is a prefix appended to urls. Source: Store.js, line 10 Methods &lt;async&gt; getAtlas(name) Gets a texture atlas thingy. Parameters: Name Type Description name string is the name of the atlas to get. Source: Store.js, line 54 Returns: the thingy. Type fish.graphics.Atlas &lt;async&gt; getSample(name) Loads a sound sample. Parameters: Name Type Description name string is the name of the sample to g4et. Source: Store.js, line 64 Returns: the sample or null if it screwed up. Type fish.audio.Sample &lt;async&gt; getTexture(name) Gets a texture. Parameters: Name Type Description name string is the name of the texture to get. Source: Store.js, line 44 Returns: the texture it got. Type fish.graphics.Texture &lt;async, inner&gt; get(name, type) Gets a thing of arbitrary type from the asset store, or creates and adds it if it cannot be found. Parameters: Name Type Description name string is the name of the thing to find. type string is the type of the thing to find. Source: Store.js, line 25 Returns: the thing if it is found or null. × Search results Close "},"fish.util.html":{"id":"fish.util.html","title":"Namespace: util","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Namespace: util fish. util Provides some basic utility stuff. Maths classes and whatever the hell ya know. Source: util.js, line 8 Classes Rect Vector Members &lt;static&gt; aRect This is a rect that you can use for stuff when you don't want to instantiate one. Just know that in between uses it's value could be arbitrary. Source: util.js, line 217 Methods &lt;static&gt; fitText(text, font, width) Takes a piece of text and fits it so that when drawn with a given font it will fit into a given width space. It ignores single newlines, and turns two or more newlines in a row into a single newline. Parameters: Name Type Description text string the text to fit. font fish.graphics.Font the font to give size to the text. width number the width to fit the text into. Source: util.js, line 172 &lt;static&gt; loadText(url) Asynchronously loads a text file in. Parameters: Name Type Description url string is the url to load the file from. Source: util.js, line 148 Returns: that resolves to the loaded file content. Type Promise.&lt;string&gt; &lt;static&gt; textHeight(text, font) Takes a fitted piece of text and tells you how high it is gonna be in the given font. Parameters: Name Type Description text string is text where every newline is taken seriously. font fish.graphics.Font is the font used to measure it. Source: util.js, line 207 Returns: the number of pixels high it will be. Type number × Search results Close "},"fish.util.Rect.html":{"id":"fish.util.Rect.html","title":"Class: Rect","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Rect fish.util. Rect Represents an axis aligned rectangle and it should be immutable I think. wait no. But I should make it immutable maybe. new Rect( [x] [, y] [, w] [, h]) Creates the rectangle. Parameters: Name Type Argument Default Description x number &lt;optional&gt; 0 is the horizontal position of the rectangle. y number &lt;optional&gt; 0 is the vertical position of the rectangle. w number &lt;optional&gt; 0 is the width of the rectangle. h number &lt;optional&gt; 0 is the height of the rectangle. Source: util.js, line 63 Members h Gets the height of the rectangle. Source: util.js, line 120 r Gets the position of the right hand side of the rectangle. Or left depending on how you look at it. Essentially it's x + w. Source: util.js, line 129 t Gets the position of the top of the rectangle. Or bottom depending on how you are thinking about it. Point is it's y + h. Source: util.js, line 138 w Gets the width of the rectangle. Source: util.js, line 112 x Gets the horizontal position of the rectangle. Source: util.js, line 96 y Gets the vertical position of the rectangle. Source: util.js, line 104 Methods shrink(amount) Shrinks the rectangle by a certain amount from each of it's former border lines. Parameters: Name Type Description amount number the amount to shrink it from each side. Source: util.js, line 85 × Search results Close "},"fish.util.Vector.html":{"id":"fish.util.Vector.html","title":"Class: Vector","body":" fish-tank Namespaces fishfish.audiofish.graphicsfish.guifish.inputfish.screenfish.util Classes fish.audio.BasicAudiofish.audio.Samplefish.graphics.Atlasfish.graphics.BitmapFontfish.graphics.Colourfish.graphics.Patchfish.graphics.SpriteRendererfish.graphics.SpriteRenderer#Batchfish.graphics.Texturefish.gui.ButtonKnobfish.gui.ContainerKnobfish.gui.HBoxKnobfish.gui.Knobfish.gui.PanelKnobfish.gui.PicKnobfish.gui.TextKnobfish.input.BasicInputfish.screen.Screenfish.screen.Transitionfish.Storefish.util.Rectfish.util.Vector Interfaces fish.audio.SamplePlayerfish.graphics.BaseRendererfish.graphics.Fontfish.graphics.PatchRendererfish.gui.Stylefish.input.UiInput Class: Vector fish.util. Vector new Vector( [x] [, y]) Represents a two dimensional point / direction via cartesian coordinates. You will notice there is no functional style stuff and that is because it requires instantiating objects and in the kinds of contexts where a vector class is most used, that is not really acceptable so yeah. Parameters: Name Type Argument Default Description x number &lt;optional&gt; 0 is the horizontal part. y number &lt;optional&gt; 0 is the vector part. Source: util.js, line 19 Methods add(other [, mag]) Adds another vector onto this one component wise. Parameters: Name Type Argument Default Description other fish.util.Vector is the other vector. mag number &lt;optional&gt; 1 is the amount to multiply the other one by first. I know it's not really that relevant to adding but it is the main use case so I might as well make it efficient and easy. Source: util.js, line 40 set( [x] [, y]) Sets both parts of the vector to new values. Parameters: Name Type Argument Default Description x number &lt;optional&gt; 0 is the new x part. y number &lt;optional&gt; 0 is the new y part. Source: util.js, line 28 wrap(bounds) Wraps this vector in a rectangle that starts at (0, 0) then goes to bounds. Parameters: Name Type Description bounds fish.util.Vector is a vector representing the far corner. Source: util.js, line 51 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
